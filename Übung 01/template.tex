\documentclass[a4paper,11pt]{scrartcl}
\usepackage[a4paper, left=2cm, right=4.5cm, top=3.5cm, bottom=2cm]{geometry} % kleinere Ränder

%Paket für Header in Koma-Klassen (scrartcl, scrrprt, scrbook, scrlttr2)
\usepackage[headsepline]{scrlayer-scrpage}
% Header groß genug für 3 Zeilen machen
\setlength{\headheight}{3\baselineskip}


% Default Header löschen
\pagestyle{scrheadings}
\clearpairofpagestyles

% nicht kursiv gedruckte header
\setkomafont{pagehead}{\sffamily\upshape}

% Links im Dokuement sowie \url schön machen
\usepackage[colorlinks,pdfpagelabels,pdfstartview = FitH, bookmarksopen = true,bookmarksnumbered = true, linkcolor = black, plainpages = false, hypertexnames = false, citecolor = black]{hyperref}

% Umlaute in der Datei erlauben, auf deutsch umstellen
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}

% Mathesymbole und Ähnliches
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{microtype}
\newcommand{\NN}{{\mathbb N}}
\newcommand{\RR}{{\mathbb R}}
\newcommand{\QQ}{{\mathbb Q}}
\newcommand{\ZZ}{{\mathbb{Z}}}

% Komplexitätsklassen
\newcommand{\pc}{\ensuremath{{\sf P}}}
\newcommand{\np}{\ensuremath{{\sf NP}}}
\newcommand{\npc}{\ensuremath{{\sf NPC}}}
\newcommand{\pspace}{\ensuremath{{\sf PSPACE}}}
\newcommand{\exptime}{\ensuremath{{\sf EXPTIME}}}
\newcommand{\CClassNP}{\textup{NP}\xspace}
\newcommand{\CClassP}{\textup{P}\xspace}

% Weitere pakete
\usepackage{multicol}
\usepackage{booktabs}

% Abbildungen
\usepackage{tikz}
\usetikzlibrary{arrows,calc}

% Meistens ist \varphi schöner als \phi, genauso bei \theta
\renewcommand{\phi}{\varphi}
\renewcommand{\theta}{\vartheta}

% Aufzählungen anpassen (alternativ: \arabic, \alph)
\renewcommand{\labelenumi}{(\roman{enumi})}

% rwth colors
% colors: blue violet purple carmine red magenta orange yellow grass cyan gold silver
\definecolor{rwth-blue}{cmyk}{1,.5,0,0}\colorlet{rwth-lblue}{rwth-blue!50}\colorlet{rwth-llblue}{rwth-blue!25}
\definecolor{rwth-violet}{cmyk}{.6,.6,0,0}\colorlet{rwth-lviolet}{rwth-violet!50}\colorlet{rwth-llviolet}{rwth-violet!25}
\definecolor{rwth-purple}{cmyk}{.7,1,.35,.15}\colorlet{rwth-lpurple}{rwth-purple!50}\colorlet{rwth-llpurple}{rwth-purple!25}
\definecolor{rwth-carmine}{cmyk}{.25,1,.7,.2}\colorlet{rwth-lcarmine}{rwth-carmine!50}\colorlet{rwth-llcarmine}{rwth-carmine!25}
\definecolor{rwth-red}{cmyk}{.15,1,1,0}\colorlet{rwth-lred}{rwth-red!50}\colorlet{rwth-llred}{rwth-red!25}
\definecolor{rwth-magenta}{cmyk}{0,1,.25,0}\colorlet{rwth-lmagenta}{rwth-magenta!50}\colorlet{rwth-llmagenta}{rwth-magenta!25}
\definecolor{rwth-orange}{cmyk}{0,.4,1,0}\colorlet{rwth-lorange}{rwth-orange!50}\colorlet{rwth-llorange}{rwth-orange!25}
\definecolor{rwth-yellow}{cmyk}{0,0,1,0}\colorlet{rwth-lyellow}{rwth-yellow!50}\colorlet{rwth-llyellow}{rwth-yellow!25}
\definecolor{rwth-grass}{cmyk}{.35,0,1,0}\colorlet{rwth-lgrass}{rwth-grass!50}\colorlet{rwth-llgrass}{rwth-grass!25}
\definecolor{rwth-green}{cmyk}{.7,0,1,0}\colorlet{rwth-lgreen}{rwth-green!50}\colorlet{rwth-llgreen}{rwth-green!25}
\definecolor{rwth-cyan}{cmyk}{1,0,.4,0}\colorlet{rwth-lcyan}{rwth-cyan!50}\colorlet{rwth-llcyan}{rwth-cyan!25}
\definecolor{rwth-teal}{cmyk}{1,.3,.5,.3}\colorlet{rwth-lteal}{rwth-teal!50}\colorlet{rwth-llteal}{rwth-teal!25}
\definecolor{rwth-gold}{cmyk}{.35,.46,.7,.35}
\definecolor{rwth-silver}{cmyk}{.39,.31,.32,.14}



% Header i-> inner (bei einseitig links), c -> center, o -> Outer (bei einseitg rechts)
\ihead{SWT WS 2020/21 \\ Gruppe 010 \\\today\\
		Laura Koch, XXXXXX\\
		Marc Ludevid, 405401\\
		Til Mohr, 405959}
\chead{\Large Aufgabenblatt 1}
\ohead{Andrés Montoya, 405409 \\
	   Dobri Panayotov, XXXXXX \\
	   Fabian Grob, XXXXXX \\
	   Lennart Holzenkamp, XXXXXX\\
	   Simon Michau, 406133\\
	   Tim Luther, 410886}
	
\cfoot*{\pagemark} % Seitenzahlen unten

\begin{document}
		
	\section*{Aufgabe 1.1}
	\subsection*{a)}
	\begin{table}[h!]
		\begin{tabular}{l|l|l|l|l|l}
		 \textbf{Tätigkeit} 										&A &E &I &T &W \\ 
		 \hline
		 Benutzer der Software schulen								&  &  &  &x &  \\
		 Qualitätssicherung des Pflichtenheftes prüfen				&  &  &  &x &  \\
		 Gesetzliche Rahmenbedingungen prüfen						&x &  &  &  &  \\
		 Konzept und Prototyp einer Benutzeroberfläche erstellen	&  &x &  &  &  \\
		 Entwicklerteam zusammenstellen								&x &  &  &  &  \\
		 Code eines Programmmoduls debuggen							&  &  &x &x &x \\
 		 Zwei Subsysteme verbinden und testen						&  &  &x &x &  \\
 		 Termine und Kosten des Projektes planen					&x &  &  &  &  \\
		 Datenstrukturen festlegen									&  &x &x &  &  \\
		 Vorhandene Altlasten des Kunden analysieren				&x &  &  &  &  \\
		 Schnittstellen von Programmmodulen definieren				&  &x &  &  &  \\
		 Leistung der Entwickler bewerten und belohnen				&  &  &  &  &  \\
		 Software an neue Umgebung anpassen							&  &  &  &x &x \\
		 Kunden eine Rechnung stellen								&  &  &  &  &  \\
		 Test-Eingabedaten für ein Programmmodul ermitteln			&  &  &  &x &  \\ 
		 Strukturmodell des gesamten Softwaresystems entwerfen		&  &x &  &  &  \\ 
		 Dokumentation des Projektablaufes bewerten und archivieren	&  &  &  &  &  \\ 
		 Nach bereits vorhandenen, wiederverwendbaren 				&x &x &x &  &  \\ 
		 	     Software-Bibliotheken suchen	&  &  &  &  &  \\ 	
		 Performance-Prognose des Softwaresystems erstellen			&  &x &x &  &  \\ 
		 Programmcode kommentieren									&  &  &x &x &x \\ 
		\end{tabular}
	\end{table}
	*A=Analyse; E=Entwurf; I=Implementierung; T=Test/Integration; W=Wartung\\
	\\\textbf{Begründungen:}\\
	Benutzer der Software schulen: \textcolor{gray}{Gehört ja klar zu der Integration.}\\
	Qualitätssicherung des Pflichtenheftes prüfen: \textcolor{gray}{Zum Test der Software, ob alles auch wie gewünscht funktioniert.}\\
	Gesetzliche Rahmenbedingungen prüfen: \textcolor{gray}{Der gesetzliche Rahmen sollte geklärt sein, bevor das Produkt entwickelt wird.}\\
	Konzept und Prototyp einer Benutzeroberfläche erstellen: \textcolor{gray}{Konzept und Prototyp müssen erstellt werden, nachdem in der Analyse bestimmt wurde welche Anforderungen erfüllt werden sollen, aber bevor die Implementierung startet, damit die Entwickler wissen was zu tun ist.} \\
	Entwicklerteam zusammenstellen: \textcolor{gray}{Das Entwicklerteam sollte an das Projekt angepasst werden, bevor dieses startet, aber nachdem geklärt wurde welche Qualifikationen erforderlich sind. Einzelne Teammitglieder können während der Entwicklung noch angepasst werden.}\\
	Code eines Programmmoduls debuggen: \textcolor{gray}{Kann immer passieren, wenn mit konkretem Code gearbeitet wird, vorausgesetzt ein Programm existiert bereits.}\\			
 	Zwei Subsysteme verbinden und testen: \textcolor{gray}{Verbindung in Implementation \& Integration, Testen in Test.}\\			
 	Termine und Kosten des Projektes planen: \textcolor{gray}{Sollte erledigt sein bevor das Projekt startet.}\\		
	Datenstrukturen festlegen: \textcolor{gray}{Sollte im Entwurf festgelegt werden, damit die Entwickler sie implementieren können. Kann während der Implementierung noch angepasst werden.}\\				
	Vorhandene Altlasten des Kunden analysieren: \textcolor{gray}{Wichtig zum Entwurf, sollte also in Analyse geschehen.}\\			
	Schnittstellen von Programmmodulen definieren: \textcolor{gray}{Wenn die Implementation in Modulen erfolgt, sollte vorher klar geregelt sein, wie die Module später miteinander arbeiten. Daher sollte das im Entwurf geschehen.}\\			
	Leistung der Entwickler bewerten und belohnen: \textcolor{gray}{Gehört nicht wirklich zur Softwareentwicklung.}\\
	Software an neue Umgebung anpassen: \textcolor{gray}{Wartung der Software und Integration in neue Umgebung.}\\		
	Kunden eine Rechnung stellen: \textcolor{gray}{Gehört zwar nicht wirklich zur Softwareentwicklung, könnte aber durchaus in jedem Schritt geschehen.}\\				
	Test-Eingabedaten für ein Programmmodul ermitteln: \textcolor{gray}{Gehört klar zu den Tests.}\\	
	Strukturmodell des gesamten Softwaresystems entwerfen: \textcolor{gray}{Gehört klar zu dem Entwurf.}\\
	Dokumentation des Projektablaufes bewerten und archivieren: \textcolor{gray}{Nirgendwo wirklich wichtig, es sei denn angefragt. Dann zu T+W.}\\	
	Nach bereits vorhandenen, wiederverwendbaren Software-Bibliotheken suchen: \textcolor{gray}{Kann so früh beginnen wie in der späten Analyse bis hin zu der Implementation, um die Software zu entwerfen und auch implementieren.}\\
	Performance-Prognose des Softwaresystems erstellen: \textcolor{gray}{Sollte früh geschehen, damit man die Implementation auch darauf abrichten kann.}\\
	Programmcode kommentieren: \textcolor{gray}{In jeder Phase, wo man Code implementiert.}\\	
	
\newpage	
	
	\subsection*{b)}
	\begin{table}[h!]
		\begin{tabular}{l|l|l|l|l|l|l|l|l}
		 \textbf{Tätigkeit} 										&A &GE&FE&I &MT&IT&ST&AT \\ 
		 \hline
		 Benutzer der Software schulen								&  &  &  &  &  &  &  &  \\
		 Qualitätssicherung des Pflichtenheftes prüfen				&  &  &  &  &x &x &x &x \\
		 Gesetzliche Rahmenbedingungen prüfen						&x &  &  &  &  &  &  &  \\
		 Konzept und Prototyp einer Benutzeroberfläche erstellen	&  &x &x &  &  &  &  &  \\
		 Entwicklerteam zusammenstellen								&x &x &  &  &  &  &  &  \\
		 Code eines Programmmoduls debuggen							&  &  &  &x &x &x &x &x \\
 		 Zwei Subsysteme verbinden und testen						&  &  &  &  &  &x &x &  \\
 		 Termine und Kosten des Projektes planen					&x &  &  &  &  &  &  &  \\
		 Datenstrukturen festlegen									&  &x &x &x &  &  &  &  \\
		 Vorhandene Altlasten des Kunden analysieren				&x &  &  &  &  &  &  &  \\
		 Schnittstellen von Programmmodulen definieren				&  &x &x &  &  &  &  &  \\
		 Leistung der Entwickler bewerten und belohnen				&  &  &  &  &  &  &  &  \\
		 Software an neue Umgebung anpassen							&  &  &  &x &x &x &x &x \\
		 Kunden eine Rechnung stellen								&  &  &  &  &  &  &  &  \\
		 Test-Eingabedaten für ein Programmmodul ermitteln			&  &  &  &  &x &x &x &x \\ 
		 Strukturmodell des gesamten Softwaresystems entwerfen		&  &x &x &  &  &  &  &  \\
		 Dokumentation des Projektablaufes bewerten und archivieren	&  &  &  &  &  &  &  &  \\
		 Nach bereits vorhandenen, wiederverwendbaren 				&x &x &x &x &  &  &  &  \\
		 	     Software-Bibliotheken suchen	&  &  &  &  &  &  &  &  \\ 	
		 Performance-Prognose des Softwaresystems erstellen			&  &  &x &x &  &  &  &  \\
		 Programmcode kommentieren									&  &  &  &x &x &x &x &x \\ 
		\end{tabular}
	\end{table}
	*A=Analyse; GE=Grobentwurf; FE=Feinentwurf; I=Implementation; MT=Modultest; IT=Integrationstest; ST=Systemtest; AT=Abnahmetest\\
	\\\textbf{Begründungen:}\\
	Benutzer der Software schulen: \textcolor{gray}{Keinen Platz im V-Modell}\\
	Qualitätssicherung des Pflichtenheftes prüfen: \textcolor{gray}{In jedem Test kann man schon überprüfen, ob die Qualität eingehalten ist.}\\
	Gesetzliche Rahmenbedingungen prüfen: \textcolor{gray}{Der gesetzliche Rahmen sollte geklärt sein, bevor das Produkt entwickelt wird.}\\
	Konzept und Prototyp einer Benutzeroberfläche erstellen: \textcolor{gray}{Konzept und Prototyp müssen erstellt werden, nachdem in der Analyse bestimmt wurde welche Anforderungen erfüllt werden sollen, aber bevor die Implementierung startet, damit die Entwickler wissen was zu tun ist.} \\
	Entwicklerteam zusammenstellen: \textcolor{gray}{Das Entwicklerteam sollte an das Projekt angepasst werden, bevor dieses startet, aber nachdem geklärt wurde welche Qualifikationen erforderlich sind. Einzelne Teammitglieder können während der Entwicklung noch angepasst werden.}\\
	Code eines Programmmoduls debuggen: \textcolor{gray}{Kann immer passieren, wenn mit konkretem Code gearbeitet wird, vorausgesetzt ein Programm existiert bereits.}\\			
 	Zwei Subsysteme verbinden und testen: \textcolor{gray}{Sollte dann geschehen, wenn Module integriert werden und das System getestet wird.}\\			
 	Termine und Kosten des Projektes planen: \textcolor{gray}{Sollte erledigt sein bevor das Projekt startet.}\\
	Datenstrukturen festlegen: \textcolor{gray}{Sollte im Entwurf festgelegt werden, damit die Entwickler sie implementieren können. Kann während der Implementierung noch angepasst werden.}\\				
	Vorhandene Altlasten des Kunden analysieren: \textcolor{gray}{Wichtig zum Entwurf, sollte also in Analyse geschehen.}\\			
	Schnittstellen von Programmmodulen definieren: \textcolor{gray}{Wenn die Implementation in Modulen erfolgt, sollte vorher klar geregelt sein, wie die Module später miteinander arbeiten. Daher sollte das im Entwurf geschehen.}\\			
	Leistung der Entwickler bewerten und belohnen: \textcolor{gray}{Gehört nicht wirklich zur Softwareentwicklung.}\\
	Software an neue Umgebung anpassen: \textcolor{gray}{Implementation nötiger Änderungen und testen in der neuen Umgebung.}\\		
	Kunden eine Rechnung stellen: \textcolor{gray}{Gehört zwar nicht wirklich zur Softwareentwicklung, könnte aber durchaus in jedem Schritt geschehen.}\\	
	Test-Eingabedaten für ein Programmmodul ermitteln: \textcolor{gray}{Gehört klar zu den Tests.}\\
	Strukturmodell des gesamten Softwaresystems entwerfen: \textcolor{gray}{Gehört klar zu dem Entwurf.}\\
	Dokumentation des Projektablaufes bewerten und archivieren: \textcolor{gray}{Nirgendwo wirklich wichtig, es sei denn angefragt. Dann zu T+W.}\\	
	Nach bereits vorhandenen, wiederverwendbaren Software-Bibliotheken suchen: \textcolor{gray}{Kann so früh beginnen wie in der späten Analyse bis hin zu der Implementation, um die Software zu entwerfen und auch implementieren.}\\
	Performance-Prognose des Softwaresystems erstellen: \textcolor{gray}{Sollte früh geschehen, damit man die Implementation auch darauf abrichten kann.}\\
	Programmcode kommentieren: \textcolor{gray}{In jeder Phase, wo man Code implementiert.}\\		
	
	\subsection*{c)}
	Eine starre Zuordnung der Tätigkeiten zu den Grundaktivitäten ist problematisch, weil es sinnvoller ist, einige Tätigkeiten zu unterschiedlichen Zeiten zu machen. Die Grundaktivitäten sollen ja auch nur einen groben Plan zur Softwareentwicklung geben, dieser ist also nicht für alle Fälle der effizienteste und effektivste Plan.
	
\newpage

	\section*{Aufgabe 1.2}
	
	\begin{table}[h!]
		\begin{tabular}{c|c|c|c|c}
		 \textbf{Rolle\textbackslash Aktivität} & Sprint Planning & Sprint Review & Sprint-Retrospektive & Daily Scrum \\
		 \hline
		 Product Owner		&x &x &x &  \\
		 Scrum Master		&  &x &x &x \\
		 Entwicklungsteam	&x &x &x &x \\
		\end{tabular}
	\end{table}
	
	\begin{table}[h!]
		\begin{tabular}{c|c|c|c}
		 \textbf{Rolle\textbackslash Artefakt} & Product Backlog & Sprint Backlog & Produktinkrement \\
		 \hline
		 Product Owner		&x &  &x \\
		 Scrum Master		&  &x &x \\
		 Entwicklungsteam	&x &x &x \\
		\end{tabular}
	\end{table}

	\section*{Aufgabe 1.3}
	\textbf{funktionale Anforderungen:}
	\begin{itemize}
		\item Funktionalitäten beider Arten von Ladestation gleich
		\item Überprüfung, ob Auto ordnungsgemäß angeschlossen ist, erfolgt durch Übertragung von Fahrzeugdaten
		\item Berechnung der benötigten Lademenge
		\item Äußerung des Ladewunsches
		\item Bezahlfunktion
		\item optional Schnellladen, wenn Station eine Schnellladestation ist
	\end{itemize}
	\textbf{nicht-funktionale Anforderungen}
	\begin{itemize}
		\item Bedienung über komfortables Interface
		\item Ausfallquote $< 1\%$
		\item Auto und Ladestationen interagieren miteinander
		\item Bezahlung verschlüsselt
	\end{itemize}
	
	
\end{document}

